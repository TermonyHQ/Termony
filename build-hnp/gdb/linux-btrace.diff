--- a/gdb/nat/linux-btrace.c	2025-04-21 01:22:05.000000000 +0800
+++ b/gdb/nat/linux-btrace.c	2025-08-26 10:04:03.839124442 +0800
@@ -30,6 +30,7 @@
 #include <inttypes.h>
 
 #include <sys/syscall.h>
+#include <unistd.h>
 
 #if HAVE_LINUX_PERF_EVENT_H && defined(SYS_perf_event_open)
 #include <unistd.h>
@@ -516,6 +517,8 @@
   __u64 data_offset;
   int pid, pg;
 
+  long page_size = sysconf(_SC_PAGESIZE);
+
   if (!cpu_supports_bts ())
     error (_("BTS support has been disabled for the target cpu."));
 
@@ -546,8 +549,8 @@
     diagnose_perf_event_open_fail ();
 
   /* Convert the requested size in bytes to pages (rounding up).  */
-  pages = ((size_t) conf->size / PAGE_SIZE
-	   + ((conf->size % PAGE_SIZE) == 0 ? 0 : 1));
+  pages = ((size_t) conf->size / page_size
+	   + ((conf->size % page_size) == 0 ? 0 : 1));
   /* We need at least one page.  */
   if (pages == 0)
     pages = 1;
@@ -566,17 +569,17 @@
       size_t length;
       __u64 data_size;
 
-      data_size = (__u64) pages * PAGE_SIZE;
+      data_size = (__u64) pages * page_size;
 
       /* Don't ask for more than we can represent in the configuration.  */
       if ((__u64) UINT_MAX < data_size)
 	continue;
 
       size = (size_t) data_size;
-      length = size + PAGE_SIZE;
+      length = size + page_size;
 
       /* Check for overflows.  */
-      if ((__u64) length != data_size + PAGE_SIZE)
+      if ((__u64) length != data_size + page_size)
 	continue;
 
       errno = 0;
@@ -591,7 +594,7 @@
 
   struct perf_event_mmap_page *header = (struct perf_event_mmap_page *)
     data.get ();
-  data_offset = PAGE_SIZE;
+  data_offset = page_size;
 
 #if defined (PERF_ATTR_SIZE_VER5)
   if (offsetof (struct perf_event_mmap_page, data_size) <= header->size)
@@ -664,6 +667,8 @@
   size_t pages;
   int pid, pg;
 
+  long page_size = sysconf(_SC_PAGESIZE);
+
   pid = ptid.lwp ();
   if (pid == 0)
     pid = ptid.pid ();
@@ -703,7 +708,7 @@
     diagnose_perf_event_open_fail ();
 
   /* Allocate the configuration page. */
-  scoped_mmap data (nullptr, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,
+  scoped_mmap data (nullptr, page_size, PROT_READ | PROT_WRITE, MAP_SHARED,
 		    fd.get (), 0);
   if (data.get () == MAP_FAILED)
     error (_("Failed to map trace user page: %s."), safe_strerror (errno));
@@ -714,8 +719,8 @@
   header->aux_offset = header->data_offset + header->data_size;
 
   /* Convert the requested size in bytes to pages (rounding up).  */
-  pages = ((size_t) conf->size / PAGE_SIZE
-	   + ((conf->size % PAGE_SIZE) == 0 ? 0 : 1));
+  pages = ((size_t) conf->size / page_size 
+	   + ((conf->size % page_size) == 0 ? 0 : 1));
   /* We need at least one page.  */
   if (pages == 0)
     pages = 1;
@@ -734,7 +739,7 @@
       size_t length;
       __u64 data_size;
 
-      data_size = (__u64) pages * PAGE_SIZE;
+      data_size = (__u64) pages * page_size;
 
       /* Don't ask for more than we can represent in the configuration.  */
       if ((__u64) UINT_MAX < data_size)
@@ -805,7 +810,8 @@
 static void
 linux_disable_bts (struct linux_btrace_target_info *tinfo)
 {
-  munmap ((void *) tinfo->header, tinfo->pev.size + PAGE_SIZE);
+  long page_size = sysconf(_SC_PAGESIZE);
+  munmap ((void *) tinfo->header, tinfo->pev.size + page_size);
   close (tinfo->file);
 }
 
@@ -814,8 +820,9 @@
 static void
 linux_disable_pt (struct linux_btrace_target_info *tinfo)
 {
+  long page_size = sysconf(_SC_PAGESIZE);
   munmap ((void *) tinfo->pev.mem, tinfo->pev.size);
-  munmap ((void *) tinfo->header, PAGE_SIZE);
+  munmap ((void *) tinfo->header, page_size);
   close (tinfo->file);
 }
 
